# Otus Basic
## Задание 6
## Реализация контейнеров

В задании требуется реализовать два контейнера динамического размера – последовательный и 
спискового типа – и пользовательский код с демонстрацией возможностей этих контейнеров.
1. Последовательный контейнер
Отличительная черта такого контейнера – расположение элементов друг за другом подряд 
(как и у обычного массива в стиле Си). 
2. Контейнер спискового типа – не предоставляет гарантий расположения элементов друг за другом в памяти. Связь между элементами осуществляется через указатели (указатель на предыдущий элемент и/или указатель на следующий элемент)
### Дополнительное задание 1. Реализовать последовательный контейнер с небольшим 
резервированием памяти заранее. Так при добавлении нового элемента контейнер сначала 
создаёт область памяти больше по размеру, чем нужно для размещения элементов (например, на 
50%). Таким образом при последующих добавлениях новых элементов можно будет избежать 
повторного выделения памяти и копирования. 
Примечание: выделять память со слишком большим запасом – плохое решение, так как приведёт к 
слишком значительному перерасходу памяти. Обычно используют коэффициенты 1.5, 1.6, 2.0.
### Дополнительное задание 2. Реализовать два варианта спискового контейнера: 
- двунаправленный список – каждый узел хранит указатель на следующий элемент и 
указатель на предыдущий элемент
- однонаправленный список – каждый узел хранит указатель только на следующий элемент
### Дополнительное задание 3. Использовать в реализации семантику перемещения:
- реализовать перемещающие конструктор и оператор присваивания для контейнеров
- уметь принимать на вход r-value ссылку на пользовательский объект
### Дополнительное задание 4. Реализовать дополнительную структуру – итератор, инкапсулирующую 
в себе логику обхода контейнера. Реализовать методы у контейнера:
- begin() – возвращает итератор на начало контейнера
- end() – возвращает итератор на конец контейнера
Реализовать методы у итератора:
- operator*() – унарный оператор разыменования
- и/или метод get() для получения значения.
Пример кода, который должен работать после реализации:
